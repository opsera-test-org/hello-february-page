name: "2ï¸âƒ£ CI/CD Pipeline - hpp1 (dev)"

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/1-bootstrap-*.yml'
      - 'README.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      grype_mode:
        description: 'Grype scan mode'
        required: false
        default: 'warn'
        type: choice
        options:
          - warn
          - block

env:
  APP_NAME: hpp1
  TENANT: opsera
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  NAMESPACE: opsera-hpp1-dev
  ECR_REPO_NAME: opsera/hpp1
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev
  GRYPE_MODE: ${{ github.event.inputs.grype_mode || 'warn' }}

permissions:
  contents: write
  id-token: write
  security-events: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 1: Security Scan (Gitleaks - Warn-Only by Default)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  gitleaks-scan:
    name: "Stage 1: Secret Scan"
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_SUMMARY: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 2: Build Image (Local Only - No Push)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-image:
    name: "Stage 2: Build Image"
    runs-on: ubuntu-latest
    needs: [gitleaks-scan]
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}
      short_sha: ${{ steps.image-tag.outputs.short_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Image tag: ${IMAGE_TAG}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "AWS Account: ${AWS_ACCOUNT_ID}"

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin \
            ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Build Docker image
        run: |
          ECR_URI="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_NAME }}"
          IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"

          docker build -t ${ECR_URI}:${IMAGE_TAG} .
          echo "âœ… Image built: ${ECR_URI}:${IMAGE_TAG}"

      - name: Save image for scanning
        run: |
          ECR_URI="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_NAME }}"
          IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"

          mkdir -p /tmp/docker-image
          docker save ${ECR_URI}:${IMAGE_TAG} -o /tmp/docker-image/image.tar
          echo "âœ… Image saved for scanning"

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image/image.tar
          retention-days: 1

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 3: Grype Vulnerability Scan
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  grype-scan:
    name: "Stage 3: Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: [build-image]
    outputs:
      scan_passed: ${{ steps.scan-result.outputs.passed }}
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image

      - name: Load Docker image
        run: |
          docker load -i /tmp/docker-image/image.tar
          echo "âœ… Image loaded for scanning"

      - name: Run Grype scan
        id: grype-scan
        uses: anchore/scan-action@v4
        with:
          image: "${{ needs.build-image.outputs.short_sha }}-*"
          fail-build: false
          severity-cutoff: high
          output-format: sarif

      - name: Upload SARIF to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ steps.grype-scan.outputs.sarif }}

      - name: Evaluate scan results
        id: scan-result
        run: |
          if [ "${{ env.GRYPE_MODE }}" = "block" ]; then
            if [ -f "${{ steps.grype-scan.outputs.sarif }}" ]; then
              CRITICAL_COUNT=$(jq '[.runs[].results[] | select(.level=="error")] | length' ${{ steps.grype-scan.outputs.sarif }})
              if [ "$CRITICAL_COUNT" -gt 0 ]; then
                echo "âŒ Found ${CRITICAL_COUNT} critical vulnerabilities - blocking deployment"
                echo "passed=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          fi

          echo "âœ… Scan passed (mode: ${{ env.GRYPE_MODE }})"
          echo "passed=true" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 4: Push to ECR (Unique Timestamped Tags)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  push-to-ecr:
    name: "Stage 4: Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.grype-scan.result == 'success'
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
      full_image: ${{ steps.push.outputs.full_image }}
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image

      - name: Load Docker image
        run: |
          docker load -i /tmp/docker-image/image.tar

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin \
            ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Push to ECR
        id: push
        run: |
          ECR_URI="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_NAME }}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          FULL_IMAGE="${ECR_URI}:${IMAGE_TAG}"

          docker push ${FULL_IMAGE}

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed: ${FULL_IMAGE}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 5: Refresh ECR Secret (SPOKE Cluster - Before Manifests!)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  refresh-ecr-secret:
    name: "Stage 5: Refresh ECR Secret"
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure spoke cluster access
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Create/Update ECR secret
        run: |
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          ECR_SERVER="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          kubectl --context spoke delete secret ecr-registry-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true

          kubectl --context spoke create secret docker-registry ecr-registry-secret \
            -n ${{ env.NAMESPACE }} \
            --docker-server=${ECR_SERVER} \
            --docker-username=AWS \
            --docker-password=${ECR_TOKEN}

          echo "âœ… ECR secret refreshed in namespace: ${{ env.NAMESPACE }}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 6: Update Manifests (Kustomize - Idempotent)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "Stage 6: Update Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr, refresh-ecr-secret]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update kustomization with new image
        run: |
          cd .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}

          ECR_URI="${{ needs.push-to-ecr.outputs.ecr_uri }}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"

          # Replace PLACEHOLDER_ECR_URI with actual ECR URI
          sed -i "s|PLACEHOLDER_ECR_URI|${ECR_URI}|g" kustomization.yaml

          # Update image tag
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" kustomization.yaml

          echo "âœ… Kustomization updated"
          cat kustomization.yaml

      - name: Commit and push (idempotent)
        run: |
          git add .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml

          if git diff --quiet --cached; then
            echo "âœ… No changes to commit"
            exit 0
          fi

          git commit -m "Update ${{ env.ENVIRONMENT }} image to ${{ needs.build-image.outputs.image_tag }} [skip ci]

          Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

          # Push with retry logic
          for i in {1..3}; do
            if git push origin main; then
              echo "âœ… Manifests pushed successfully"
              exit 0
            fi
            echo "Push failed, attempting rebase (attempt $i/3)"
            git pull --rebase origin main
          done

          echo "âŒ Failed to push after 3 attempts"
          exit 1

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 7: Create/Update ArgoCD Application (Idempotent - NEW v2.4)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  create-argocd-app:
    name: "Stage 7: Create ArgoCD App"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure hub cluster access
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub

      - name: Create/Update ArgoCD Application (idempotent)
        run: |
          kubectl --context hub apply -f .opsera-${{ env.APP_NAME }}/argocd/${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-application.yaml
          echo "âœ… ArgoCD application created/updated"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 8: ArgoCD Hard Refresh (HUB Cluster)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  argocd-refresh:
    name: "Stage 8: ArgoCD Refresh"
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure hub cluster access
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub

      - name: Force ArgoCD refresh
        run: |
          kubectl --context hub patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"info":[{"name":"Reason","value":"Manifest update"}]}}'

          kubectl --context hub annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            argocd.argoproj.io/refresh=hard \
            --overwrite

          echo "âœ… ArgoCD hard refresh triggered"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 9: Sync ArgoCD Application
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  argocd-sync:
    name: "Stage 9: ArgoCD Sync"
    runs-on: ubuntu-latest
    needs: [argocd-refresh]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure hub cluster access
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub

      - name: Trigger ArgoCD sync
        run: |
          kubectl --context hub patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            --type merge \
            -p '{"operation":{"sync":{"revision":"main"}}}'

          echo "âœ… ArgoCD sync triggered"

      - name: Wait for sync completion
        run: |
          echo "Waiting for sync to complete..."
          for i in {1..60}; do
            SYNC_STATUS=$(kubectl --context hub get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
              -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl --context hub get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
              -n argocd -o jsonpath='{.status.health.status}')

            echo "Sync: ${SYNC_STATUS}, Health: ${HEALTH_STATUS}"

            if [ "${SYNC_STATUS}" = "Synced" ] && [ "${HEALTH_STATUS}" = "Healthy" ]; then
              echo "âœ… Application synced and healthy"
              exit 0
            fi

            sleep 10
          done

          echo "âš ï¸ Sync timeout - check ArgoCD console"
          exit 1

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 10: Verify Deployment (SPOKE Cluster)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-deployment:
    name: "Stage 10: Verify Deployment"
    runs-on: ubuntu-latest
    needs: [argocd-sync]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure spoke cluster access
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke

      - name: Check deployment status
        run: |
          kubectl --context spoke rollout status deployment/${{ env.APP_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=5m

          echo "âœ… Deployment rolled out successfully"

      - name: Verify pods
        run: |
          kubectl --context spoke get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}

          READY_PODS=$(kubectl --context spoke get pods -n ${{ env.NAMESPACE }} \
            -l app=${{ env.APP_NAME }} \
            -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep -o True | wc -l)

          if [ "$READY_PODS" -eq 0 ]; then
            echo "âŒ No pods are ready"
            exit 1
          fi

          echo "âœ… ${READY_PODS} pod(s) ready"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 11: Deployment Landscape (Dashboard & Metrics)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deployment-landscape:
    name: "Stage 11: Deployment Landscape"
    runs-on: ubuntu-latest
    needs: [verify-deployment, push-to-ecr, build-image]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "# ğŸš€ Deployment Complete - hpp1 (dev)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ env.APP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ needs.push-to-ecr.outputs.full_image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ env.SPOKE_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Access" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://hpp1-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Stages" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Security Scan (Gitleaks)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Build Image" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Vulnerability Scan (Grype)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Push to ECR" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Refresh ECR Secret" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Update Manifests" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Create ArgoCD App" >> $GITHUB_STEP_SUMMARY
          echo "âœ… ArgoCD Refresh" >> $GITHUB_STEP_SUMMARY
          echo "âœ… ArgoCD Sync" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Verify Deployment" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Deployment Landscape" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Powered by Opsera Code-to-Cloud Enterprise v0.932*" >> $GITHUB_STEP_SUMMARY
