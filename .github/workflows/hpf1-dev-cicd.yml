name: hpf1-dev CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      grype_mode:
        description: 'Grype scan mode'
        required: false
        default: 'warn'
        type: choice
        options:
          - warn
          - block

permissions:
  contents: write
  id-token: write
  security-events: write

env:
  APP_NAME: hpf1
  ENVIRONMENT: dev
  NAMESPACE: opsera-hpf1-dev
  AWS_REGION: us-west-2
  SPOKE_CLUSTER: opsera-usw2-np
  HUB_CLUSTER: argocd-usw2
  GRYPE_MODE: ${{ inputs.grype_mode || 'warn' }}

jobs:
  # Stage 1: Security Scan (Gitleaks)
  security-scan:
    name: Stage 1 - Gitleaks Security Scan
    runs-on: ubuntu-latest
    continue-on-error: true  # Warn-only mode (RULE 205)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Gitleaks results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: results.sarif
          retention-days: 30

  # Stage 2: Build Image
  build-image:
    name: Stage 2 - Build Docker Image
    runs-on: ubuntu-latest
    needs: [security-scan]
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      short_sha: ${{ steps.meta.outputs.short_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(git rev-parse --short=8 HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "Generated image tag: $IMAGE_TAG"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (local only, no push)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: ${{ env.APP_NAME }}:${{ steps.meta.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/${{ env.APP_NAME }}-${{ steps.meta.outputs.image_tag }}.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/${{ env.APP_NAME }}-${{ steps.meta.outputs.image_tag }}.tar
          retention-days: 1

  # Stage 3: Grype Vulnerability Scan
  grype-scan:
    name: Stage 3 - Grype Vulnerability Scan
    runs-on: ubuntu-latest
    needs: [build-image]
    outputs:
      scan_passed: ${{ steps.scan.outputs.scan_passed }}

    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: |
          docker load --input /tmp/${{ env.APP_NAME }}-${{ needs.build-image.outputs.image_tag }}.tar
          docker images

      - name: Run Grype scan
        id: scan
        uses: anchore/scan-action@v4
        with:
          image: ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}
          fail-build: ${{ env.GRYPE_MODE == 'block' }}
          severity-cutoff: high
          output-format: sarif

      - name: Set scan result
        if: always()
        run: |
          if [ "${{ env.GRYPE_MODE }}" == "warn" ]; then
            echo "scan_passed=true" >> $GITHUB_OUTPUT
            echo "✅ Scan completed in warn-only mode"
          elif [ "${{ steps.scan.outcome }}" == "success" ]; then
            echo "scan_passed=true" >> $GITHUB_OUTPUT
            echo "✅ Scan passed"
          else
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            echo "❌ Scan failed in blocking mode"
          fi

      - name: Upload Grype results to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif
          category: grype

      - name: Upload Grype results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-report
          path: results.sarif
          retention-days: 30

  # Stage 4: Push to ECR
  push-to-ecr:
    name: Stage 4 - Push to ECR
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: needs.grype-scan.outputs.scan_passed == 'true' || inputs.grype_mode == 'warn'
    outputs:
      ecr_image: ${{ steps.push.outputs.ecr_image }}

    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: |
          docker load --input /tmp/${{ env.APP_NAME }}-${{ needs.build-image.outputs.image_tag }}.tar

      - name: Configure AWS Credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws sts get-caller-identity

      - name: Get AWS Account ID
        id: aws-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Tag and push image to ECR
        id: push
        run: |
          ECR_REGISTRY=${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          ECR_IMAGE=$ECR_REGISTRY/${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}

          docker tag ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }} $ECR_IMAGE
          docker push $ECR_IMAGE

          echo "ecr_image=$ECR_IMAGE" >> $GITHUB_OUTPUT
          echo "✅ Pushed image: $ECR_IMAGE"

  # Stage 5: Refresh ECR Secret (SPOKE)
  refresh-ecr-secret:
    name: Stage 5 - Refresh ECR Secret
    runs-on: ubuntu-latest
    needs: [push-to-ecr]

    steps:
      - name: Configure AWS Credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws sts get-caller-identity

      - name: Get AWS Account ID
        id: aws-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Configure kubectl for spoke cluster
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_SPOKE }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config current-context

      - name: Refresh ECR secret
        run: |
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          ECR_REGISTRY=${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

          kubectl delete secret ecr-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl create secret docker-registry ecr-secret \
            --docker-server=$ECR_REGISTRY \
            --docker-username=AWS \
            --docker-password=$ECR_TOKEN \
            --namespace=${{ env.NAMESPACE }}

          echo "✅ ECR secret refreshed"

  # Stage 6: Update Manifests
  update-manifests:
    name: Stage 6 - Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [build-image, push-to-ecr, refresh-ecr-secret]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Pull latest changes
        run: |
          git pull --rebase origin main || true

      - name: Update image tag in kustomization
        run: |
          ECR_REGISTRY=${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          KUSTOMIZATION_FILE="k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"

          sed -i "s|PLACEHOLDER_ECR_URI|$ECR_REGISTRY|g" $KUSTOMIZATION_FILE
          sed -i "s|newTag:.*|newTag: ${{ needs.build-image.outputs.image_tag }}|g" $KUSTOMIZATION_FILE

          echo "Updated kustomization.yaml with image tag: ${{ needs.build-image.outputs.image_tag }}"
          cat $KUSTOMIZATION_FILE

      - name: Update deployment image placeholder
        run: |
          ECR_REGISTRY=${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          DEPLOYMENT_FILE="k8s/base/deployment.yaml"

          sed -i "s|PLACEHOLDER_ECR_URI|$ECR_REGISTRY|g" $DEPLOYMENT_FILE

          echo "Updated deployment.yaml ECR URI"

      - name: Commit and push changes (idempotent)
        run: |
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add k8s/
            git commit -m "Update image tag to ${{ needs.build-image.outputs.image_tag }} [skip ci]

          Deployment: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}
          Image: ${{ needs.push-to-ecr.outputs.ecr_image }}
          Commit: ${{ needs.build-image.outputs.short_sha }}

          Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

            # Push with retry
            for i in {1..3}; do
              if git push origin main; then
                echo "✅ Pushed changes successfully"
                break
              else
                echo "Push failed, attempt $i of 3"
                git pull --rebase origin main
                sleep 2
              fi
            done
          fi

  # Stage 7: Create/Update ArgoCD Application (NEW v2.4)
  create-argocd-app:
    name: Stage 7 - Create ArgoCD Application
    runs-on: ubuntu-latest
    needs: [update-manifests]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure kubectl for hub cluster
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_HUB }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config current-context

      - name: Create/Update ArgoCD Application (idempotent)
        run: |
          kubectl apply -f k8s/overlays/${{ env.ENVIRONMENT }}/argocd-application.yaml
          echo "✅ ArgoCD application created/updated: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"

          kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd

  # Stage 8: ArgoCD Hard Refresh
  argocd-refresh:
    name: Stage 8 - ArgoCD Hard Refresh
    runs-on: ubuntu-latest
    needs: [create-argocd-app]

    steps:
      - name: Configure kubectl for hub cluster
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_HUB }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Trigger ArgoCD hard refresh
        run: |
          kubectl patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
            --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          echo "✅ Triggered ArgoCD hard refresh"
          sleep 5

  # Stage 9: Sync ArgoCD
  argocd-sync:
    name: Stage 9 - Sync ArgoCD Application
    runs-on: ubuntu-latest
    needs: [argocd-refresh]

    steps:
      - name: Configure kubectl for hub cluster
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_HUB }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Trigger ArgoCD sync
        run: |
          kubectl patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{},"apply":{"force":false}}}}}'

          echo "✅ Triggered ArgoCD sync"

      - name: Wait for sync to complete
        timeout-minutes: 5
        run: |
          echo "Waiting for ArgoCD sync to complete..."
          for i in {1..60}; do
            SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o jsonpath='{.status.health.status}')

            echo "Sync: $SYNC_STATUS | Health: $HEALTH_STATUS"

            if [ "$SYNC_STATUS" == "Synced" ] && [ "$HEALTH_STATUS" == "Healthy" ]; then
              echo "✅ Application synced and healthy"
              exit 0
            fi

            sleep 5
          done

          echo "❌ Sync timeout"
          kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd
          exit 1

  # Stage 10: Verify Deployment
  verify-deployment:
    name: Stage 10 - Verify Deployment
    runs-on: ubuntu-latest
    needs: [argocd-sync]

    steps:
      - name: Configure kubectl for spoke cluster
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_SPOKE }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Verify pods are running
        timeout-minutes: 3
        run: |
          echo "Verifying pods in namespace ${{ env.NAMESPACE }}..."
          kubectl wait --for=condition=ready pod -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=180s

          echo "✅ All pods ready"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}

      - name: Verify deployment rollout
        run: |
          kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=180s
          echo "✅ Deployment rollout complete"

      - name: Get deployment info
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}

          echo ""
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}

          echo ""
          echo "=== Service ==="
          kubectl get service ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}

  # Stage 11: Deployment Landscape
  deployment-landscape:
    name: Stage 11 - Deployment Landscape
    runs-on: ubuntu-latest
    needs: [build-image, verify-deployment]
    if: always() && needs.verify-deployment.result == 'success'

    steps:
      - name: Generate deployment summary
        run: |
          cat << EOF > deployment-summary.txt
          ╔══════════════════════════════════════════════════════════════════╗
          ║           DEPLOYMENT SUCCESSFUL - ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}
          ╚══════════════════════════════════════════════════════════════════╝

          Application:   ${{ env.APP_NAME }}
          Environment:   ${{ env.ENVIRONMENT }}
          Namespace:     ${{ env.NAMESPACE }}
          Image Tag:     ${{ needs.build-image.outputs.image_tag }}
          Commit:        ${{ needs.build-image.outputs.short_sha }}
          Cluster:       ${{ env.SPOKE_CLUSTER }}

          Deployed at:   $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Duration:      ${{ github.event.repository.updated_at }}

          ✅ All verification checks passed
          EOF

          cat deployment-summary.txt

      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.txt
          retention-days: 90

      - name: Post deployment status
        run: |
          echo "::notice::✅ Deployment completed successfully for ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          echo "::notice::Image: ${{ needs.build-image.outputs.image_tag }}"
