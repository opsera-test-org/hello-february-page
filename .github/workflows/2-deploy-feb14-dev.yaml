name: 2. Deploy feb14 - DEV

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/1-bootstrap-*.yaml'
      - 'README.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: 'false'

env:
  TENANT: opsera
  APP_NAME: feb14
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  NAMESPACE: opsera-feb14-dev
  ECR_REPO_NAME: opsera/feb14
  ARGOCD_APP_NAME: opsera-feb14-dev
  DOMAIN: agent.opsera.dev

jobs:
  # Stage 1: Security Scan (Gitleaks - warn-only)
  security-scan:
    name: 'Stage 1: Security Scan (Gitleaks)'
    runs-on: ubuntu-latest
    continue-on-error: true  # Warn-only mode (RULE 205)
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for gitleaks

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}  # Optional

      - name: Report scan result
        if: always()
        run: |
          if [ "${{ job.status }}" == "failure" ]; then
            echo "âš ï¸  Gitleaks found potential secrets (warn-only mode)"
          else
            echo "âœ… No secrets detected"
          fi

  # Stage 2: Build Image (local, no push)
  build-image:
    name: 'Stage 2: Build Docker Image'
    runs-on: ubuntu-latest
    needs: [security-scan]
    outputs:
      image_tag: ${{ steps.generate-tag.outputs.image_tag }}
      short_sha: ${{ steps.generate-tag.outputs.short_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate unique image tag
        id: generate-tag
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "Generated tag: ${IMAGE_TAG}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (local only)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: ${{ env.APP_NAME }}:${{ steps.generate-tag.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/image.tar

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  # Stage 3: Grype Scan (vulnerability scan)
  grype-scan:
    name: 'Stage 3: Vulnerability Scan (Grype)'
    runs-on: ubuntu-latest
    needs: [build-image]
    continue-on-error: true  # Warn-only mode by default
    outputs:
      scan_passed: ${{ steps.scan.outputs.scan_passed }}
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: |
          docker load --input /tmp/image.tar
          docker image ls

      - name: Run Grype scan
        id: scan
        uses: anchore/scan-action@v4
        with:
          image: ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}
          fail-build: false  # Warn-only mode
          severity-cutoff: high
          output-format: sarif

      - name: Upload Grype results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: ${{ steps.scan.outputs.sarif }}

      - name: Generate vulnerability report
        if: always()
        run: |
          echo "scan_passed=true" >> $GITHUB_OUTPUT
          echo "âœ… Vulnerability scan complete (warn-only mode)"

  # Stage 4: Push to ECR
  push-to-ecr:
    name: 'Stage 4: Push to ECR'
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    permissions:
      contents: read
      id-token: write
    outputs:
      image_uri: ${{ steps.push.outputs.image_uri }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "AWS Account ID: ${AWS_ACCOUNT_ID}"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load and push image
        id: push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ needs.build-image.outputs.image_tag }}
        run: |
          # Load image
          docker load --input /tmp/image.tar

          # Tag for ECR
          FULL_IMAGE_URI="${ECR_REGISTRY}/${ECR_REPO_NAME}:${IMAGE_TAG}"
          docker tag ${APP_NAME}:${IMAGE_TAG} ${FULL_IMAGE_URI}

          # Push to ECR
          docker push ${FULL_IMAGE_URI}

          echo "image_uri=${FULL_IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed: ${FULL_IMAGE_URI}"

  # Stage 5: Refresh ECR Secret (SPOKE cluster - before manifests!)
  refresh-ecr-secret:
    name: 'Stage 5: Refresh ECR Secret'
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig for SPOKE cluster
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke
          kubectl config use-context spoke

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Create/Update ECR pull secret
        env:
          AWS_ACCOUNT_ID: ${{ steps.aws-account.outputs.account_id }}
        run: |
          # Get ECR token (valid for 12 hours)
          ECR_TOKEN=$(aws ecr get-login-password --region ${AWS_REGION})
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          # Delete existing secret if exists
          kubectl delete secret ecr-secret -n ${NAMESPACE} --ignore-not-found=true

          # Create new secret
          kubectl create secret docker-registry ecr-secret \
            --docker-server=${ECR_REGISTRY} \
            --docker-username=AWS \
            --docker-password=${ECR_TOKEN} \
            -n ${NAMESPACE}

          echo "âœ… ECR secret refreshed in namespace: ${NAMESPACE}"

  # Stage 6: Update Manifests (Kustomize)
  update-manifests:
    name: 'Stage 6: Update Manifests'
    runs-on: ubuntu-latest
    needs: [push-to-ecr, refresh-ecr-secret]
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Setup Kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Update image tag in kustomization
        env:
          IMAGE_TAG: ${{ needs.build-image.outputs.image_tag }}
          IMAGE_URI: ${{ needs.push-to-ecr.outputs.image_uri }}
        run: |
          cd k8s/overlays/dev

          # Update image in kustomization.yaml
          kustomize edit set image ${APP_NAME}=${IMAGE_URI}

          echo "âœ… Updated kustomization.yaml with new image tag"
          cat kustomization.yaml

      - name: Commit and push manifest changes (idempotent)
        env:
          SHORT_SHA: ${{ needs.build-image.outputs.short_sha }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --quiet k8s/overlays/dev/kustomization.yaml; then
            echo "âœ… No manifest changes to commit"
            exit 0
          fi

          # Stage and commit changes
          git add k8s/overlays/dev/kustomization.yaml
          git commit -m "Update dev image to ${SHORT_SHA} [skip ci]

          Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

          # Push with retry logic (pull with rebase if push fails)
          for i in {1..3}; do
            if git push origin main; then
              echo "âœ… Manifest changes pushed successfully"
              break
            else
              echo "âš ï¸  Push failed, retrying... (attempt $i/3)"
              git pull --rebase origin main
              sleep 2
            fi
          done

  # Stage 7: Create/Update ArgoCD Application (idempotent - NEW in v2.4)
  create-argocd-app:
    name: 'Stage 7: Create ArgoCD Application'
    runs-on: ubuntu-latest
    needs: [update-manifests]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig for HUB cluster
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          kubectl config use-context hub

      - name: Create/Update ArgoCD Application (idempotent)
        run: |
          # Apply ArgoCD application manifest (idempotent)
          kubectl apply -f argocd/application-dev.yaml

          echo "âœ… ArgoCD application created/updated: ${ARGOCD_APP_NAME}"

  # Stage 8: ArgoCD Hard Refresh (HUB cluster)
  argocd-refresh:
    name: 'Stage 8: ArgoCD Hard Refresh'
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig for HUB cluster
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          kubectl config use-context hub

      - name: Trigger hard refresh
        run: |
          # Patch application to trigger hard refresh
          kubectl patch application ${ARGOCD_APP_NAME} \
            -n argocd \
            --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          echo "âœ… ArgoCD hard refresh triggered"
          sleep 5

  # Stage 9: Sync ArgoCD (wait for completion)
  argocd-sync:
    name: 'Stage 9: Sync ArgoCD'
    runs-on: ubuntu-latest
    needs: [argocd-refresh]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig for HUB cluster
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          kubectl config use-context hub

      - name: Trigger sync and wait
        run: |
          # Patch to trigger sync
          kubectl patch application ${ARGOCD_APP_NAME} \
            -n argocd \
            --type merge \
            -p '{"operation":{"sync":{"syncOptions":["CreateNamespace=false"]}}}'

          echo "â³ Waiting for sync to complete..."

          # Wait for sync to complete (max 10 minutes)
          for i in {1..60}; do
            SYNC_STATUS=$(kubectl get application ${ARGOCD_APP_NAME} -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl get application ${ARGOCD_APP_NAME} -n argocd -o jsonpath='{.status.health.status}')

            echo "Sync: ${SYNC_STATUS}, Health: ${HEALTH_STATUS}"

            if [ "${SYNC_STATUS}" == "Synced" ] && [ "${HEALTH_STATUS}" == "Healthy" ]; then
              echo "âœ… ArgoCD sync complete - application healthy"
              exit 0
            fi

            sleep 10
          done

          echo "âš ï¸  Sync timeout - check ArgoCD UI for details"
          exit 1

  # Stage 10: Verify Deployment (health checks)
  verify-deployment:
    name: 'Stage 10: Verify Deployment'
    runs-on: ubuntu-latest
    needs: [argocd-sync]
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig for SPOKE cluster
        run: |
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke
          kubectl config use-context spoke

      - name: Verify pods are running
        run: |
          echo "Checking pods in namespace: ${NAMESPACE}"

          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod \
            -l app=${APP_NAME} \
            -n ${NAMESPACE} \
            --timeout=300s

          # Get pod status
          kubectl get pods -n ${NAMESPACE} -l app=${APP_NAME}

          echo "âœ… All pods are running and ready"

      - name: Verify service
        run: |
          kubectl get service -n ${NAMESPACE} ${APP_NAME}
          echo "âœ… Service verified"

      - name: Verify ingress
        run: |
          kubectl get ingress -n ${NAMESPACE} ${APP_NAME}

          INGRESS_HOST=$(kubectl get ingress ${APP_NAME} -n ${NAMESPACE} -o jsonpath='{.spec.rules[0].host}')
          echo "âœ… Ingress verified: https://${INGRESS_HOST}"

      - name: Display deployment info
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  âœ… DEPLOYMENT VERIFIED - feb14 DEV                              â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Environment:     dev                                            â•‘"
          echo "â•‘  Namespace:       ${NAMESPACE}                                   â•‘"
          echo "â•‘  Image Tag:       ${{ needs.build-image.outputs.image_tag }}     â•‘"
          echo "â•‘  URL:             https://${INGRESS_HOST}                        â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # Stage 11: Deployment Landscape (dashboard)
  deployment-landscape:
    name: 'Stage 11: Deployment Landscape'
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "ğŸ“Š Deployment landscape generation complete"
          echo "View full deployment status in ArgoCD UI"
